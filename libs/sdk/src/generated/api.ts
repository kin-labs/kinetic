/* tslint:disable */
/* eslint-disable */
/**
 * Mogami
 * The Mogami API description
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface AirdropRequest
 */
export interface AirdropRequest {
  /**
   *
   * @type {string}
   * @memberof AirdropRequest
   */
  account: string
  /**
   *
   * @type {string}
   * @memberof AirdropRequest
   */
  amount?: string
}
/**
 *
 * @export
 * @interface AirdropResponse
 */
export interface AirdropResponse {
  /**
   *
   * @type {string}
   * @memberof AirdropResponse
   */
  signature: string
}
/**
 *
 * @export
 * @interface AirdropStats
 */
export interface AirdropStats {
  /**
   *
   * @type {AirdropStatsCounts}
   * @memberof AirdropStats
   */
  counts: AirdropStatsCounts
  /**
   *
   * @type {Array<string>}
   * @memberof AirdropStats
   */
  dates: Array<string>
}
/**
 *
 * @export
 * @interface AirdropStatsCounts
 */
export interface AirdropStatsCounts {
  /**
   *
   * @type {number}
   * @memberof AirdropStatsCounts
   */
  averageValue: number
  /**
   *
   * @type {number}
   * @memberof AirdropStatsCounts
   */
  total: number
  /**
   *
   * @type {number}
   * @memberof AirdropStatsCounts
   */
  totalValue: number
}
/**
 *
 * @export
 * @interface ApiConfigSummary
 */
export interface ApiConfigSummary {
  /**
   *
   * @type {number}
   * @memberof ApiConfigSummary
   */
  port: number
  /**
   *
   * @type {string}
   * @memberof ApiConfigSummary
   */
  environment: string
  /**
   *
   * @type {string}
   * @memberof ApiConfigSummary
   */
  solanaRpcEndpoint: string
}
/**
 *
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
  /**
   *
   * @type {string}
   * @memberof BalanceResponse
   */
  value: string
}
/**
 *
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
  /**
   *
   * @type {string}
   * @memberof CreateAccountRequest
   */
  tx: string
}
/**
 *
 * @export
 * @interface CreateAccountResponse
 */
export interface CreateAccountResponse {
  /**
   *
   * @type {string}
   * @memberof CreateAccountResponse
   */
  status: string
  /**
   *
   * @type {object}
   * @memberof CreateAccountResponse
   */
  account: object
}
/**
 *
 * @export
 * @interface HealthCheckResponse
 */
export interface HealthCheckResponse {
  /**
   *
   * @type {boolean}
   * @memberof HealthCheckResponse
   */
  isSolanaOk: boolean
  /**
   *
   * @type {boolean}
   * @memberof HealthCheckResponse
   */
  isMogamiOk: boolean
  /**
   *
   * @type {string}
   * @memberof HealthCheckResponse
   */
  time: string
}
/**
 *
 * @export
 * @interface HistoryResponse
 */
export interface HistoryResponse {
  /**
   *
   * @type {object}
   * @memberof HistoryResponse
   */
  account: object
  /**
   *
   * @type {Array<string>}
   * @memberof HistoryResponse
   */
  history: Array<string>
}
/**
 *
 * @export
 * @interface MinimumBalanceForRentExemptionResponse
 */
export interface MinimumBalanceForRentExemptionResponse {
  /**
   *
   * @type {number}
   * @memberof MinimumBalanceForRentExemptionResponse
   */
  lamports: number
}
/**
 *
 * @export
 * @interface MinimumKinVersionResponse
 */
export interface MinimumKinVersionResponse {
  /**
   *
   * @type {number}
   * @memberof MinimumKinVersionResponse
   */
  version: number
}
/**
 *
 * @export
 * @interface RecentBlockhashResponse
 */
export interface RecentBlockhashResponse {
  /**
   *
   * @type {string}
   * @memberof RecentBlockhashResponse
   */
  blockhash: string
}
/**
 *
 * @export
 * @interface ServiceConfigResponse
 */
export interface ServiceConfigResponse {
  /**
   *
   * @type {string}
   * @memberof ServiceConfigResponse
   */
  mint: string
  /**
   *
   * @type {string}
   * @memberof ServiceConfigResponse
   */
  subsidizer: string
  /**
   *
   * @type {string}
   * @memberof ServiceConfigResponse
   */
  tokenProgram: string
}
/**
 *
 * @export
 * @interface SubmitPaymentRequest
 */
export interface SubmitPaymentRequest {
  /**
   *
   * @type {string}
   * @memberof SubmitPaymentRequest
   */
  tx: string
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiAccountFeatureControllerGetAccountInfo: async (
      accountId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('apiAccountFeatureControllerGetAccountInfo', 'accountId', accountId)
      const localVarPath = `/api/account/info/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {CreateAccountRequest} createAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccount: async (
      createAccountRequest: CreateAccountRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createAccountRequest' is not null or undefined
      assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
      const localVarPath = `/api/account/create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalance: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getBalance', 'accountId', accountId)
      const localVarPath = `/api/account/balance/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHistory: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getHistory', 'accountId', accountId)
      const localVarPath = `/api/account/history/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokenAccounts: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('tokenAccounts', 'accountId', accountId)
      const localVarPath = `/api/account/token-accounts/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiAccountFeatureControllerGetAccountInfo(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountFeatureControllerGetAccountInfo(
        accountId,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {CreateAccountRequest} createAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccount(
      createAccountRequest: CreateAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAccountResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBalance(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBalance(accountId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHistory(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHistory(accountId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokenAccounts(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tokenAccounts(accountId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AccountApiFp(configuration)
  return {
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiAccountFeatureControllerGetAccountInfo(accountId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiAccountFeatureControllerGetAccountInfo(accountId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {CreateAccountRequest} createAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccount(createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<CreateAccountResponse> {
      return localVarFp.createAccount(createAccountRequest, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalance(accountId: string, options?: any): AxiosPromise<BalanceResponse> {
      return localVarFp.getBalance(accountId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHistory(accountId: string, options?: any): AxiosPromise<HistoryResponse> {
      return localVarFp.getHistory(accountId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokenAccounts(accountId: string, options?: any): AxiosPromise<Array<string>> {
      return localVarFp.tokenAccounts(accountId, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
  /**
   *
   * @param {string} accountId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public apiAccountFeatureControllerGetAccountInfo(accountId: string, options?: AxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .apiAccountFeatureControllerGetAccountInfo(accountId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {CreateAccountRequest} createAccountRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .createAccount(createAccountRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} accountId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public getBalance(accountId: string, options?: AxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .getBalance(accountId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} accountId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public getHistory(accountId: string, options?: AxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .getHistory(accountId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} accountId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public tokenAccounts(accountId: string, options?: AxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .tokenAccounts(accountId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AirdropApi - axios parameter creator
 * @export
 */
export const AirdropApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {AirdropRequest} airdropRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    airdropRequest: async (airdropRequest: AirdropRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'airdropRequest' is not null or undefined
      assertParamExists('airdropRequest', 'airdropRequest', airdropRequest)
      const localVarPath = `/api/airdrop`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(airdropRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    airdropStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/airdrop/stats`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AirdropApi - functional programming interface
 * @export
 */
export const AirdropApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AirdropApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {AirdropRequest} airdropRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async airdropRequest(
      airdropRequest: AirdropRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AirdropResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.airdropRequest(airdropRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async airdropStats(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AirdropStats>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.airdropStats(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AirdropApi - factory interface
 * @export
 */
export const AirdropApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AirdropApiFp(configuration)
  return {
    /**
     *
     * @param {AirdropRequest} airdropRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    airdropRequest(airdropRequest: AirdropRequest, options?: any): AxiosPromise<AirdropResponse> {
      return localVarFp.airdropRequest(airdropRequest, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    airdropStats(options?: any): AxiosPromise<AirdropStats> {
      return localVarFp.airdropStats(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AirdropApi - object-oriented interface
 * @export
 * @class AirdropApi
 * @extends {BaseAPI}
 */
export class AirdropApi extends BaseAPI {
  /**
   *
   * @param {AirdropRequest} airdropRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AirdropApi
   */
  public airdropRequest(airdropRequest: AirdropRequest, options?: AxiosRequestConfig) {
    return AirdropApiFp(this.configuration)
      .airdropRequest(airdropRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AirdropApi
   */
  public airdropStats(options?: AxiosRequestConfig) {
    return AirdropApiFp(this.configuration)
      .airdropStats(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    config: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async config(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConfigSummary>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.config(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ConfigApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    config(options?: any): AxiosPromise<ApiConfigSummary> {
      return localVarFp.config(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApi
   */
  public config(options?: AxiosRequestConfig) {
    return ConfigApiFp(this.configuration)
      .config(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCoreFeatureControllerUptime: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/uptime`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/health-check`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCoreFeatureControllerUptime(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCoreFeatureControllerUptime(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthCheck(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCoreFeatureControllerUptime(options?: any): AxiosPromise<void> {
      return localVarFp.apiCoreFeatureControllerUptime(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthCheck(options?: any): AxiosPromise<HealthCheckResponse> {
      return localVarFp.healthCheck(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public apiCoreFeatureControllerUptime(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .apiCoreFeatureControllerUptime(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public healthCheck(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .healthCheck(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTransactionFeatureControllerGetHistory: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/transaction/history`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTransactionFeatureControllerSignTransaction: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/transaction/sign-transaction`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} dataLength
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMinimumBalanceForRentExemption: async (
      dataLength: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataLength' is not null or undefined
      assertParamExists('getMinimumBalanceForRentExemption', 'dataLength', dataLength)
      const localVarPath = `/api/transaction/minimum-balance-for-rent-exemption/{dataLength}`.replace(
        `{${'dataLength'}}`,
        encodeURIComponent(String(dataLength)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMinimumKinVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/transaction/minimum-kin-version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecentBlockhash: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/transaction/recent-blockhash`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/transaction/service-config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {SubmitPaymentRequest} submitPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitTransaction: async (
      submitPaymentRequest: SubmitPaymentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'submitPaymentRequest' is not null or undefined
      assertParamExists('submitTransaction', 'submitPaymentRequest', submitPaymentRequest)
      const localVarPath = `/api/transaction/submit-transaction`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(submitPaymentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiTransactionFeatureControllerGetHistory(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionFeatureControllerGetHistory(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiTransactionFeatureControllerSignTransaction(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionFeatureControllerSignTransaction(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {number} dataLength
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMinimumBalanceForRentExemption(
      dataLength: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MinimumBalanceForRentExemptionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMinimumBalanceForRentExemption(dataLength, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMinimumKinVersion(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MinimumKinVersionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMinimumKinVersion(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecentBlockhash(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecentBlockhashResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentBlockhash(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServiceConfig(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceConfigResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceConfig(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {SubmitPaymentRequest} submitPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitTransaction(
      submitPaymentRequest: SubmitPaymentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submitTransaction(submitPaymentRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TransactionApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTransactionFeatureControllerGetHistory(options?: any): AxiosPromise<void> {
      return localVarFp.apiTransactionFeatureControllerGetHistory(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiTransactionFeatureControllerSignTransaction(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiTransactionFeatureControllerSignTransaction(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} dataLength
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMinimumBalanceForRentExemption(
      dataLength: number,
      options?: any,
    ): AxiosPromise<MinimumBalanceForRentExemptionResponse> {
      return localVarFp
        .getMinimumBalanceForRentExemption(dataLength, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMinimumKinVersion(options?: any): AxiosPromise<MinimumKinVersionResponse> {
      return localVarFp.getMinimumKinVersion(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecentBlockhash(options?: any): AxiosPromise<RecentBlockhashResponse> {
      return localVarFp.getRecentBlockhash(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceConfig(options?: any): AxiosPromise<ServiceConfigResponse> {
      return localVarFp.getServiceConfig(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {SubmitPaymentRequest} submitPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitTransaction(submitPaymentRequest: SubmitPaymentRequest, options?: any): AxiosPromise<object> {
      return localVarFp.submitTransaction(submitPaymentRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public apiTransactionFeatureControllerGetHistory(options?: AxiosRequestConfig) {
    return TransactionApiFp(this.configuration)
      .apiTransactionFeatureControllerGetHistory(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public apiTransactionFeatureControllerSignTransaction(options?: AxiosRequestConfig) {
    return TransactionApiFp(this.configuration)
      .apiTransactionFeatureControllerSignTransaction(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} dataLength
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getMinimumBalanceForRentExemption(dataLength: number, options?: AxiosRequestConfig) {
    return TransactionApiFp(this.configuration)
      .getMinimumBalanceForRentExemption(dataLength, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getMinimumKinVersion(options?: AxiosRequestConfig) {
    return TransactionApiFp(this.configuration)
      .getMinimumKinVersion(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getRecentBlockhash(options?: AxiosRequestConfig) {
    return TransactionApiFp(this.configuration)
      .getRecentBlockhash(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getServiceConfig(options?: AxiosRequestConfig) {
    return TransactionApiFp(this.configuration)
      .getServiceConfig(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {SubmitPaymentRequest} submitPaymentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public submitTransaction(submitPaymentRequest: SubmitPaymentRequest, options?: AxiosRequestConfig) {
    return TransactionApiFp(this.configuration)
      .submitTransaction(submitPaymentRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
