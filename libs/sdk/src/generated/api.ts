/* tslint:disable */
/* eslint-disable */
/**
 * @kin-kinetic/api
 * The OpenAPI definition of the Kinetic API
 *
 * The version of the OpenAPI document: 1.0.0-rc.16
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface AccountInfo
 */
export interface AccountInfo {
  /**
   *
   * @type {string}
   * @memberof AccountInfo
   */
  account: string
  /**
   *
   * @type {boolean}
   * @memberof AccountInfo
   */
  isMint: boolean
  /**
   *
   * @type {boolean}
   * @memberof AccountInfo
   */
  isOwner: boolean
  /**
   *
   * @type {boolean}
   * @memberof AccountInfo
   */
  isTokenAccount: boolean
  /**
   *
   * @type {string}
   * @memberof AccountInfo
   */
  owner?: string | null
  /**
   *
   * @type {string}
   * @memberof AccountInfo
   */
  program?: string | null
  /**
   *
   * @type {Array<TokenInfo>}
   * @memberof AccountInfo
   */
  tokens?: Array<TokenInfo> | null
}
/**
 *
 * @export
 * @interface AppConfig
 */
export interface AppConfig {
  /**
   *
   * @type {AppConfigApp}
   * @memberof AppConfig
   */
  app: AppConfigApp
  /**
   *
   * @type {AppConfigApi}
   * @memberof AppConfig
   */
  api: AppConfigApi
  /**
   *
   * @type {AppConfigEnvironment}
   * @memberof AppConfig
   */
  environment: AppConfigEnvironment
  /**
   *
   * @type {AppConfigMint}
   * @memberof AppConfig
   */
  mint: AppConfigMint
  /**
   *
   * @type {Array<AppConfigMint>}
   * @memberof AppConfig
   */
  mints: Array<AppConfigMint>
}
/**
 *
 * @export
 * @interface AppConfigApi
 */
export interface AppConfigApi {
  /**
   *
   * @type {string}
   * @memberof AppConfigApi
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof AppConfigApi
   */
  version: string
}
/**
 *
 * @export
 * @interface AppConfigApp
 */
export interface AppConfigApp {
  /**
   *
   * @type {number}
   * @memberof AppConfigApp
   */
  index: number
  /**
   *
   * @type {string}
   * @memberof AppConfigApp
   */
  name: string
}
/**
 *
 * @export
 * @interface AppConfigCluster
 */
export interface AppConfigCluster {
  /**
   *
   * @type {string}
   * @memberof AppConfigCluster
   */
  endpoint: string
  /**
   *
   * @type {string}
   * @memberof AppConfigCluster
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof AppConfigCluster
   */
  name: string
  /**
   *
   * @type {ClusterType}
   * @memberof AppConfigCluster
   */
  type: ClusterType
}
/**
 *
 * @export
 * @interface AppConfigEnvironment
 */
export interface AppConfigEnvironment {
  /**
   *
   * @type {string}
   * @memberof AppConfigEnvironment
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof AppConfigEnvironment
   */
  explorer: string
  /**
   *
   * @type {AppConfigCluster}
   * @memberof AppConfigEnvironment
   */
  cluster: AppConfigCluster
}
/**
 *
 * @export
 * @interface AppConfigMint
 */
export interface AppConfigMint {
  /**
   *
   * @type {boolean}
   * @memberof AppConfigMint
   */
  addMemo: boolean
  /**
   *
   * @type {boolean}
   * @memberof AppConfigMint
   */
  airdrop: boolean
  /**
   *
   * @type {number}
   * @memberof AppConfigMint
   */
  airdropAmount?: number | null
  /**
   *
   * @type {number}
   * @memberof AppConfigMint
   */
  airdropMax?: number | null
  /**
   *
   * @type {number}
   * @memberof AppConfigMint
   */
  decimals: number
  /**
   *
   * @type {string}
   * @memberof AppConfigMint
   */
  feePayer: string
  /**
   *
   * @type {string}
   * @memberof AppConfigMint
   */
  logoUrl: string
  /**
   *
   * @type {string}
   * @memberof AppConfigMint
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof AppConfigMint
   */
  programId: string
  /**
   *
   * @type {string}
   * @memberof AppConfigMint
   */
  publicKey: string
  /**
   *
   * @type {string}
   * @memberof AppConfigMint
   */
  symbol: string
}
/**
 *
 * @export
 * @interface AppHealth
 */
export interface AppHealth {
  /**
   *
   * @type {boolean}
   * @memberof AppHealth
   */
  isSolanaOk: boolean
  /**
   *
   * @type {boolean}
   * @memberof AppHealth
   */
  isKineticOk: boolean
  /**
   *
   * @type {string}
   * @memberof AppHealth
   */
  time: string
}
/**
 *
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
  /**
   *
   * @type {string}
   * @memberof BalanceResponse
   */
  balance: string
  /**
   *
   * @type {object}
   * @memberof BalanceResponse
   */
  mints: object
  /**
   *
   * @type {Array<BalanceToken>}
   * @memberof BalanceResponse
   */
  tokens: Array<BalanceToken>
}
/**
 *
 * @export
 * @interface BalanceToken
 */
export interface BalanceToken {
  /**
   *
   * @type {string}
   * @memberof BalanceToken
   */
  account: string
  /**
   *
   * @type {string}
   * @memberof BalanceToken
   */
  balance: string
  /**
   *
   * @type {number}
   * @memberof BalanceToken
   */
  decimals: number
  /**
   *
   * @type {string}
   * @memberof BalanceToken
   */
  mint: string
}
/**
 *
 * @export
 * @interface CloseAccountRequest
 */
export interface CloseAccountRequest {
  /**
   *
   * @type {Commitment}
   * @memberof CloseAccountRequest
   */
  commitment: Commitment
  /**
   *
   * @type {string}
   * @memberof CloseAccountRequest
   */
  account: string
  /**
   *
   * @type {string}
   * @memberof CloseAccountRequest
   */
  environment: string
  /**
   *
   * @type {number}
   * @memberof CloseAccountRequest
   */
  index: number
  /**
   *
   * @type {string}
   * @memberof CloseAccountRequest
   */
  mint: string
  /**
   *
   * @type {string}
   * @memberof CloseAccountRequest
   */
  reference?: string | null
}
/**
 *
 * @export
 * @enum {string}
 */

export const ClusterType = {
  Custom: 'Custom',
  SolanaDevnet: 'SolanaDevnet',
  SolanaMainnet: 'SolanaMainnet',
  SolanaTestnet: 'SolanaTestnet',
} as const

export type ClusterType = (typeof ClusterType)[keyof typeof ClusterType]

/**
 *
 * @export
 * @enum {string}
 */

export const Commitment = {
  Confirmed: 'Confirmed',
  Finalized: 'Finalized',
  Processed: 'Processed',
} as const

export type Commitment = (typeof Commitment)[keyof typeof Commitment]

/**
 *
 * @export
 * @interface CompiledInnerInstruction
 */
export interface CompiledInnerInstruction {
  /**
   *
   * @type {number}
   * @memberof CompiledInnerInstruction
   */
  index: number
  /**
   *
   * @type {Array<CompiledInstruction>}
   * @memberof CompiledInnerInstruction
   */
  instructions: Array<CompiledInstruction>
}
/**
 *
 * @export
 * @interface CompiledInstruction
 */
export interface CompiledInstruction {
  /**
   *
   * @type {number}
   * @memberof CompiledInstruction
   */
  programIdIndex: number
  /**
   *
   * @type {Array<number>}
   * @memberof CompiledInstruction
   */
  accounts: Array<number>
  /**
   *
   * @type {string}
   * @memberof CompiledInstruction
   */
  data: string
}
/**
 *
 * @export
 * @enum {string}
 */

export const ConfirmationStatus = {
  Processed: 'processed',
  Confirmed: 'confirmed',
  Finalized: 'finalized',
} as const

export type ConfirmationStatus = (typeof ConfirmationStatus)[keyof typeof ConfirmationStatus]

/**
 *
 * @export
 * @interface ConfirmedSignatureInfo
 */
export interface ConfirmedSignatureInfo {
  /**
   *
   * @type {string}
   * @memberof ConfirmedSignatureInfo
   */
  signature: string
  /**
   *
   * @type {number}
   * @memberof ConfirmedSignatureInfo
   */
  slot?: number | null
  /**
   *
   * @type {string}
   * @memberof ConfirmedSignatureInfo
   */
  err?: string | null
  /**
   *
   * @type {string}
   * @memberof ConfirmedSignatureInfo
   */
  memo?: string | null
  /**
   *
   * @type {number}
   * @memberof ConfirmedSignatureInfo
   */
  blockTime?: number | null
}
/**
 *
 * @export
 * @interface ConfirmedTransactionMeta
 */
export interface ConfirmedTransactionMeta {
  /**
   *
   * @type {number}
   * @memberof ConfirmedTransactionMeta
   */
  fee?: number | null
  /**
   *
   * @type {Array<CompiledInnerInstruction>}
   * @memberof ConfirmedTransactionMeta
   */
  innerInstructions?: Array<CompiledInnerInstruction> | null
  /**
   *
   * @type {Array<number>}
   * @memberof ConfirmedTransactionMeta
   */
  preBalances?: Array<number> | null
  /**
   *
   * @type {Array<number>}
   * @memberof ConfirmedTransactionMeta
   */
  postBalances: Array<number>
  /**
   *
   * @type {Array<string>}
   * @memberof ConfirmedTransactionMeta
   */
  logMessages?: Array<string> | null
  /**
   *
   * @type {Array<TokenBalance>}
   * @memberof ConfirmedTransactionMeta
   */
  preTokenBalances?: Array<TokenBalance> | null
  /**
   *
   * @type {Array<TokenBalance>}
   * @memberof ConfirmedTransactionMeta
   */
  postTokenBalances?: Array<TokenBalance> | null
  /**
   *
   * @type {object}
   * @memberof ConfirmedTransactionMeta
   */
  err?: object | null
}
/**
 *
 * @export
 * @interface Context
 */
export interface Context {
  /**
   *
   * @type {number}
   * @memberof Context
   */
  slot?: number | null
}
/**
 *
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
  /**
   *
   * @type {Commitment}
   * @memberof CreateAccountRequest
   */
  commitment: Commitment
  /**
   *
   * @type {string}
   * @memberof CreateAccountRequest
   */
  environment: string
  /**
   *
   * @type {number}
   * @memberof CreateAccountRequest
   */
  index: number
  /**
   *
   * @type {number}
   * @memberof CreateAccountRequest
   */
  lastValidBlockHeight: number
  /**
   *
   * @type {string}
   * @memberof CreateAccountRequest
   */
  mint: string
  /**
   *
   * @type {string}
   * @memberof CreateAccountRequest
   */
  reference?: string | null
  /**
   *
   * @type {string}
   * @memberof CreateAccountRequest
   */
  tx: string
}
/**
 *
 * @export
 * @interface GetTransactionResponse
 */
export interface GetTransactionResponse {
  /**
   *
   * @type {string}
   * @memberof GetTransactionResponse
   */
  signature: string
  /**
   *
   * @type {RpcResponseAndContext}
   * @memberof GetTransactionResponse
   */
  status: RpcResponseAndContext
  /**
   *
   * @type {TransactionResponse}
   * @memberof GetTransactionResponse
   */
  transaction: TransactionResponse
}
/**
 *
 * @export
 * @interface HistoryResponse
 */
export interface HistoryResponse {
  /**
   *
   * @type {string}
   * @memberof HistoryResponse
   */
  account: string
  /**
   *
   * @type {Array<ConfirmedSignatureInfo>}
   * @memberof HistoryResponse
   */
  history: Array<ConfirmedSignatureInfo>
}
/**
 *
 * @export
 * @interface LatestBlockhashResponse
 */
export interface LatestBlockhashResponse {
  /**
   *
   * @type {string}
   * @memberof LatestBlockhashResponse
   */
  blockhash: string
  /**
   *
   * @type {number}
   * @memberof LatestBlockhashResponse
   */
  lastValidBlockHeight: number
}
/**
 *
 * @export
 * @interface MakeTransferRequest
 */
export interface MakeTransferRequest {
  /**
   *
   * @type {Commitment}
   * @memberof MakeTransferRequest
   */
  commitment: Commitment
  /**
   *
   * @type {string}
   * @memberof MakeTransferRequest
   */
  environment: string
  /**
   *
   * @type {number}
   * @memberof MakeTransferRequest
   */
  index: number
  /**
   *
   * @type {string}
   * @memberof MakeTransferRequest
   */
  mint: string
  /**
   *
   * @type {number}
   * @memberof MakeTransferRequest
   */
  lastValidBlockHeight: number
  /**
   *
   * @type {string}
   * @memberof MakeTransferRequest
   */
  reference?: string | null
  /**
   *
   * @type {string}
   * @memberof MakeTransferRequest
   */
  tx: string
}
/**
 *
 * @export
 * @interface MinimumRentExemptionBalanceResponse
 */
export interface MinimumRentExemptionBalanceResponse {
  /**
   *
   * @type {number}
   * @memberof MinimumRentExemptionBalanceResponse
   */
  lamports: number
}
/**
 *
 * @export
 * @interface RequestAirdropRequest
 */
export interface RequestAirdropRequest {
  /**
   *
   * @type {string}
   * @memberof RequestAirdropRequest
   */
  account: string
  /**
   *
   * @type {string}
   * @memberof RequestAirdropRequest
   */
  amount?: string | null
  /**
   *
   * @type {Commitment}
   * @memberof RequestAirdropRequest
   */
  commitment: Commitment
  /**
   *
   * @type {string}
   * @memberof RequestAirdropRequest
   */
  environment: string
  /**
   *
   * @type {number}
   * @memberof RequestAirdropRequest
   */
  index: number
  /**
   *
   * @type {string}
   * @memberof RequestAirdropRequest
   */
  mint: string
}
/**
 *
 * @export
 * @interface RequestAirdropResponse
 */
export interface RequestAirdropResponse {
  /**
   *
   * @type {string}
   * @memberof RequestAirdropResponse
   */
  signature: string
}
/**
 *
 * @export
 * @interface RpcResponseAndContext
 */
export interface RpcResponseAndContext {
  /**
   *
   * @type {Context}
   * @memberof RpcResponseAndContext
   */
  context: Context
  /**
   *
   * @type {SignatureStatus}
   * @memberof RpcResponseAndContext
   */
  value: SignatureStatus
}
/**
 *
 * @export
 * @interface SignatureStatus
 */
export interface SignatureStatus {
  /**
   *
   * @type {number}
   * @memberof SignatureStatus
   */
  slot?: number | null
  /**
   *
   * @type {number}
   * @memberof SignatureStatus
   */
  confirmations?: number | null
  /**
   *
   * @type {object}
   * @memberof SignatureStatus
   */
  err?: object | null
  /**
   *
   * @type {ConfirmationStatus}
   * @memberof SignatureStatus
   */
  confirmationStatus?: ConfirmationStatus
}
/**
 *
 * @export
 * @interface TokenAmount
 */
export interface TokenAmount {
  /**
   *
   * @type {string}
   * @memberof TokenAmount
   */
  amount: string
  /**
   *
   * @type {number}
   * @memberof TokenAmount
   */
  decimals: number
  /**
   *
   * @type {number}
   * @memberof TokenAmount
   */
  uiAmount?: number | null
  /**
   *
   * @type {string}
   * @memberof TokenAmount
   */
  uiAmountString?: string | null
}
/**
 *
 * @export
 * @interface TokenBalance
 */
export interface TokenBalance {
  /**
   *
   * @type {number}
   * @memberof TokenBalance
   */
  accountIndex: number
  /**
   *
   * @type {string}
   * @memberof TokenBalance
   */
  mint: string
  /**
   *
   * @type {string}
   * @memberof TokenBalance
   */
  owner?: string | null
  /**
   *
   * @type {TokenAmount}
   * @memberof TokenBalance
   */
  uiTokenAmount: TokenAmount
}
/**
 *
 * @export
 * @interface TokenInfo
 */
export interface TokenInfo {
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  account: string
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  balance?: string | null
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  closeAuthority?: string | null
  /**
   *
   * @type {number}
   * @memberof TokenInfo
   */
  decimals: number
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  mint: string
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  owner?: string | null
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  id?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  createdAt?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  updatedAt?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  amount?: string | null
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  decimals?: number | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  destination?: string | null
  /**
   *
   * @type {Array<TransactionError>}
   * @memberof Transaction
   */
  errors?: Array<TransactionError> | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  explorerUrl?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  feePayer?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  ip?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  mint?: string | null
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  processingDuration?: number | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  reference?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  signature?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  solanaCommitted?: string | null
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  solanaCommittedDuration?: number | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  solanaFinalized?: string | null
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  solanaFinalizedDuration?: number | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  solanaStart?: string | null
  /**
   *
   * @type {object}
   * @memberof Transaction
   */
  solanaTransaction?: object | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  source?: string | null
  /**
   *
   * @type {TransactionStatus}
   * @memberof Transaction
   */
  status?: TransactionStatus
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  totalDuration?: number | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  tx?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  ua?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  webhookEventStart?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  webhookEventEnd?: string | null
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  webhookEventDuration?: number | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  webhookVerifyStart?: string | null
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  webhookVerifyEnd?: string | null
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  webhookVerifyDuration?: number | null
}
/**
 *
 * @export
 * @interface TransactionData
 */
export interface TransactionData {
  /**
   *
   * @type {object}
   * @memberof TransactionData
   */
  message: object
  /**
   *
   * @type {Array<string>}
   * @memberof TransactionData
   */
  signatures: Array<string>
}
/**
 *
 * @export
 * @interface TransactionError
 */
export interface TransactionError {
  /**
   *
   * @type {string}
   * @memberof TransactionError
   */
  id: string
  /**
   *
   * @type {Array<string>}
   * @memberof TransactionError
   */
  logs: Array<string>
  /**
   *
   * @type {string}
   * @memberof TransactionError
   */
  message: string
  /**
   *
   * @type {TransactionErrorType}
   * @memberof TransactionError
   */
  type: TransactionErrorType
  /**
   *
   * @type {number}
   * @memberof TransactionError
   */
  instruction: number
}
/**
 *
 * @export
 * @enum {string}
 */

export const TransactionErrorType = {
  BadNonce: 'BadNonce',
  InvalidAccount: 'InvalidAccount',
  SomeError: 'SomeError',
  Timeout: 'Timeout',
  Unknown: 'Unknown',
  WebhookFailed: 'WebhookFailed',
} as const

export type TransactionErrorType = (typeof TransactionErrorType)[keyof typeof TransactionErrorType]

/**
 *
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
  /**
   *
   * @type {number}
   * @memberof TransactionResponse
   */
  slot?: number | null
  /**
   *
   * @type {TransactionData}
   * @memberof TransactionResponse
   */
  transaction: TransactionData
  /**
   *
   * @type {ConfirmedTransactionMeta}
   * @memberof TransactionResponse
   */
  meta: ConfirmedTransactionMeta
  /**
   *
   * @type {number}
   * @memberof TransactionResponse
   */
  blockTime?: number | null
}
/**
 *
 * @export
 * @enum {string}
 */

export const TransactionStatus = {
  Committed: 'Committed',
  Confirmed: 'Confirmed',
  Failed: 'Failed',
  Finalized: 'Finalized',
  Processing: 'Processing',
} as const

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {CloseAccountRequest} closeAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeAccount: async (
      closeAccountRequest: CloseAccountRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'closeAccountRequest' is not null or undefined
      assertParamExists('closeAccount', 'closeAccountRequest', closeAccountRequest)
      const localVarPath = `/api/account/close`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(closeAccountRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {CreateAccountRequest} createAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccount: async (
      createAccountRequest: CreateAccountRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createAccountRequest' is not null or undefined
      assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
      const localVarPath = `/api/account/create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {string} mint
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountInfo: async (
      environment: string,
      index: number,
      accountId: string,
      mint: string,
      commitment: Commitment,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'environment' is not null or undefined
      assertParamExists('getAccountInfo', 'environment', environment)
      // verify required parameter 'index' is not null or undefined
      assertParamExists('getAccountInfo', 'index', index)
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccountInfo', 'accountId', accountId)
      // verify required parameter 'mint' is not null or undefined
      assertParamExists('getAccountInfo', 'mint', mint)
      // verify required parameter 'commitment' is not null or undefined
      assertParamExists('getAccountInfo', 'commitment', commitment)
      const localVarPath = `/api/account/info/{environment}/{index}/{accountId}/{mint}`
        .replace(`{${'environment'}}`, encodeURIComponent(String(environment)))
        .replace(`{${'index'}}`, encodeURIComponent(String(index)))
        .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)))
        .replace(`{${'mint'}}`, encodeURIComponent(String(mint)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (commitment !== undefined) {
        localVarQueryParameter['commitment'] = commitment
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalance: async (
      environment: string,
      index: number,
      accountId: string,
      commitment: Commitment,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'environment' is not null or undefined
      assertParamExists('getBalance', 'environment', environment)
      // verify required parameter 'index' is not null or undefined
      assertParamExists('getBalance', 'index', index)
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getBalance', 'accountId', accountId)
      // verify required parameter 'commitment' is not null or undefined
      assertParamExists('getBalance', 'commitment', commitment)
      const localVarPath = `/api/account/balance/{environment}/{index}/{accountId}`
        .replace(`{${'environment'}}`, encodeURIComponent(String(environment)))
        .replace(`{${'index'}}`, encodeURIComponent(String(index)))
        .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (commitment !== undefined) {
        localVarQueryParameter['commitment'] = commitment
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {string} mint
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHistory: async (
      environment: string,
      index: number,
      accountId: string,
      mint: string,
      commitment: Commitment,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'environment' is not null or undefined
      assertParamExists('getHistory', 'environment', environment)
      // verify required parameter 'index' is not null or undefined
      assertParamExists('getHistory', 'index', index)
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getHistory', 'accountId', accountId)
      // verify required parameter 'mint' is not null or undefined
      assertParamExists('getHistory', 'mint', mint)
      // verify required parameter 'commitment' is not null or undefined
      assertParamExists('getHistory', 'commitment', commitment)
      const localVarPath = `/api/account/history/{environment}/{index}/{accountId}/{mint}`
        .replace(`{${'environment'}}`, encodeURIComponent(String(environment)))
        .replace(`{${'index'}}`, encodeURIComponent(String(index)))
        .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)))
        .replace(`{${'mint'}}`, encodeURIComponent(String(mint)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (commitment !== undefined) {
        localVarQueryParameter['commitment'] = commitment
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {string} mint
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenAccounts: async (
      environment: string,
      index: number,
      accountId: string,
      mint: string,
      commitment: Commitment,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'environment' is not null or undefined
      assertParamExists('getTokenAccounts', 'environment', environment)
      // verify required parameter 'index' is not null or undefined
      assertParamExists('getTokenAccounts', 'index', index)
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getTokenAccounts', 'accountId', accountId)
      // verify required parameter 'mint' is not null or undefined
      assertParamExists('getTokenAccounts', 'mint', mint)
      // verify required parameter 'commitment' is not null or undefined
      assertParamExists('getTokenAccounts', 'commitment', commitment)
      const localVarPath = `/api/account/token-accounts/{environment}/{index}/{accountId}/{mint}`
        .replace(`{${'environment'}}`, encodeURIComponent(String(environment)))
        .replace(`{${'index'}}`, encodeURIComponent(String(index)))
        .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)))
        .replace(`{${'mint'}}`, encodeURIComponent(String(mint)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (commitment !== undefined) {
        localVarQueryParameter['commitment'] = commitment
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary
     * @param {CloseAccountRequest} closeAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async closeAccount(
      closeAccountRequest: CloseAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.closeAccount(closeAccountRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {CreateAccountRequest} createAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccount(
      createAccountRequest: CreateAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {string} mint
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountInfo(
      environment: string,
      index: number,
      accountId: string,
      mint: string,
      commitment: Commitment,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInfo(
        environment,
        index,
        accountId,
        mint,
        commitment,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBalance(
      environment: string,
      index: number,
      accountId: string,
      commitment: Commitment,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBalance(
        environment,
        index,
        accountId,
        commitment,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {string} mint
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHistory(
      environment: string,
      index: number,
      accountId: string,
      mint: string,
      commitment: Commitment,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HistoryResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHistory(
        environment,
        index,
        accountId,
        mint,
        commitment,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {string} mint
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTokenAccounts(
      environment: string,
      index: number,
      accountId: string,
      mint: string,
      commitment: Commitment,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenAccounts(
        environment,
        index,
        accountId,
        mint,
        commitment,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AccountApiFp(configuration)
  return {
    /**
     *
     * @summary
     * @param {CloseAccountRequest} closeAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeAccount(closeAccountRequest: CloseAccountRequest, options?: any): AxiosPromise<Transaction> {
      return localVarFp.closeAccount(closeAccountRequest, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {CreateAccountRequest} createAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccount(createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<Transaction> {
      return localVarFp.createAccount(createAccountRequest, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {string} mint
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountInfo(
      environment: string,
      index: number,
      accountId: string,
      mint: string,
      commitment: Commitment,
      options?: any,
    ): AxiosPromise<AccountInfo> {
      return localVarFp
        .getAccountInfo(environment, index, accountId, mint, commitment, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalance(
      environment: string,
      index: number,
      accountId: string,
      commitment: Commitment,
      options?: any,
    ): AxiosPromise<BalanceResponse> {
      return localVarFp
        .getBalance(environment, index, accountId, commitment, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {string} mint
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHistory(
      environment: string,
      index: number,
      accountId: string,
      mint: string,
      commitment: Commitment,
      options?: any,
    ): AxiosPromise<Array<HistoryResponse>> {
      return localVarFp
        .getHistory(environment, index, accountId, mint, commitment, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} accountId
     * @param {string} mint
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenAccounts(
      environment: string,
      index: number,
      accountId: string,
      mint: string,
      commitment: Commitment,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getTokenAccounts(environment, index, accountId, mint, commitment, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AccountApi - interface
 * @export
 * @interface AccountApi
 */
export interface AccountApiInterface {
  /**
   *
   * @summary
   * @param {CloseAccountRequest} closeAccountRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApiInterface
   */
  closeAccount(closeAccountRequest: CloseAccountRequest, options?: AxiosRequestConfig): AxiosPromise<Transaction>

  /**
   *
   * @summary
   * @param {CreateAccountRequest} createAccountRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApiInterface
   */
  createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): AxiosPromise<Transaction>

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} accountId
   * @param {string} mint
   * @param {Commitment} commitment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApiInterface
   */
  getAccountInfo(
    environment: string,
    index: number,
    accountId: string,
    mint: string,
    commitment: Commitment,
    options?: AxiosRequestConfig,
  ): AxiosPromise<AccountInfo>

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} accountId
   * @param {Commitment} commitment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApiInterface
   */
  getBalance(
    environment: string,
    index: number,
    accountId: string,
    commitment: Commitment,
    options?: AxiosRequestConfig,
  ): AxiosPromise<BalanceResponse>

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} accountId
   * @param {string} mint
   * @param {Commitment} commitment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApiInterface
   */
  getHistory(
    environment: string,
    index: number,
    accountId: string,
    mint: string,
    commitment: Commitment,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<HistoryResponse>>

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} accountId
   * @param {string} mint
   * @param {Commitment} commitment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApiInterface
   */
  getTokenAccounts(
    environment: string,
    index: number,
    accountId: string,
    mint: string,
    commitment: Commitment,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<string>>
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI implements AccountApiInterface {
  /**
   *
   * @summary
   * @param {CloseAccountRequest} closeAccountRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public closeAccount(closeAccountRequest: CloseAccountRequest, options?: AxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .closeAccount(closeAccountRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {CreateAccountRequest} createAccountRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .createAccount(createAccountRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} accountId
   * @param {string} mint
   * @param {Commitment} commitment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public getAccountInfo(
    environment: string,
    index: number,
    accountId: string,
    mint: string,
    commitment: Commitment,
    options?: AxiosRequestConfig,
  ) {
    return AccountApiFp(this.configuration)
      .getAccountInfo(environment, index, accountId, mint, commitment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} accountId
   * @param {Commitment} commitment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public getBalance(
    environment: string,
    index: number,
    accountId: string,
    commitment: Commitment,
    options?: AxiosRequestConfig,
  ) {
    return AccountApiFp(this.configuration)
      .getBalance(environment, index, accountId, commitment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} accountId
   * @param {string} mint
   * @param {Commitment} commitment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public getHistory(
    environment: string,
    index: number,
    accountId: string,
    mint: string,
    commitment: Commitment,
    options?: AxiosRequestConfig,
  ) {
    return AccountApiFp(this.configuration)
      .getHistory(environment, index, accountId, mint, commitment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} accountId
   * @param {string} mint
   * @param {Commitment} commitment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public getTokenAccounts(
    environment: string,
    index: number,
    accountId: string,
    mint: string,
    commitment: Commitment,
    options?: AxiosRequestConfig,
  ) {
    return AccountApiFp(this.configuration)
      .getTokenAccounts(environment, index, accountId, mint, commitment, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AirdropApi - axios parameter creator
 * @export
 */
export const AirdropApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {RequestAirdropRequest} requestAirdropRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestAirdrop: async (
      requestAirdropRequest: RequestAirdropRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestAirdropRequest' is not null or undefined
      assertParamExists('requestAirdrop', 'requestAirdropRequest', requestAirdropRequest)
      const localVarPath = `/api/airdrop`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(requestAirdropRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AirdropApi - functional programming interface
 * @export
 */
export const AirdropApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AirdropApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary
     * @param {RequestAirdropRequest} requestAirdropRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestAirdrop(
      requestAirdropRequest: RequestAirdropRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestAirdropResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.requestAirdrop(requestAirdropRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AirdropApi - factory interface
 * @export
 */
export const AirdropApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AirdropApiFp(configuration)
  return {
    /**
     *
     * @summary
     * @param {RequestAirdropRequest} requestAirdropRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestAirdrop(requestAirdropRequest: RequestAirdropRequest, options?: any): AxiosPromise<RequestAirdropResponse> {
      return localVarFp.requestAirdrop(requestAirdropRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AirdropApi - interface
 * @export
 * @interface AirdropApi
 */
export interface AirdropApiInterface {
  /**
   *
   * @summary
   * @param {RequestAirdropRequest} requestAirdropRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AirdropApiInterface
   */
  requestAirdrop(
    requestAirdropRequest: RequestAirdropRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<RequestAirdropResponse>
}

/**
 * AirdropApi - object-oriented interface
 * @export
 * @class AirdropApi
 * @extends {BaseAPI}
 */
export class AirdropApi extends BaseAPI implements AirdropApiInterface {
  /**
   *
   * @summary
   * @param {RequestAirdropRequest} requestAirdropRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AirdropApi
   */
  public requestAirdrop(requestAirdropRequest: RequestAirdropRequest, options?: AxiosRequestConfig) {
    return AirdropApiFp(this.configuration)
      .requestAirdrop(requestAirdropRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AppApi - axios parameter creator
 * @export
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppConfig: async (
      environment: string,
      index: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'environment' is not null or undefined
      assertParamExists('getAppConfig', 'environment', environment)
      // verify required parameter 'index' is not null or undefined
      assertParamExists('getAppConfig', 'index', index)
      const localVarPath = `/api/app/{environment}/{index}/config`
        .replace(`{${'environment'}}`, encodeURIComponent(String(environment)))
        .replace(`{${'index'}}`, encodeURIComponent(String(index)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppHealth: async (
      environment: string,
      index: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'environment' is not null or undefined
      assertParamExists('getAppHealth', 'environment', environment)
      // verify required parameter 'index' is not null or undefined
      assertParamExists('getAppHealth', 'index', index)
      const localVarPath = `/api/app/{environment}/{index}/health`
        .replace(`{${'environment'}}`, encodeURIComponent(String(environment)))
        .replace(`{${'index'}}`, encodeURIComponent(String(index)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AppApi - functional programming interface
 * @export
 */
export const AppApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppConfig(
      environment: string,
      index: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppConfig>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAppConfig(environment, index, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppHealth(
      environment: string,
      index: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppHealth>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAppHealth(environment, index, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AppApi - factory interface
 * @export
 */
export const AppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AppApiFp(configuration)
  return {
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppConfig(environment: string, index: number, options?: any): AxiosPromise<AppConfig> {
      return localVarFp.getAppConfig(environment, index, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppHealth(environment: string, index: number, options?: any): AxiosPromise<AppHealth> {
      return localVarFp.getAppHealth(environment, index, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AppApi - interface
 * @export
 * @interface AppApi
 */
export interface AppApiInterface {
  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppApiInterface
   */
  getAppConfig(environment: string, index: number, options?: AxiosRequestConfig): AxiosPromise<AppConfig>

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppApiInterface
   */
  getAppHealth(environment: string, index: number, options?: AxiosRequestConfig): AxiosPromise<AppHealth>
}

/**
 * AppApi - object-oriented interface
 * @export
 * @class AppApi
 * @extends {BaseAPI}
 */
export class AppApi extends BaseAPI implements AppApiInterface {
  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppApi
   */
  public getAppConfig(environment: string, index: number, options?: AxiosRequestConfig) {
    return AppApiFp(this.configuration)
      .getAppConfig(environment, index, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppApi
   */
  public getAppHealth(environment: string, index: number, options?: AxiosRequestConfig) {
    return AppApiFp(this.configuration)
      .getAppHealth(environment, index, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} reference
     * @param {string} signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKineticTransaction: async (
      environment: string,
      index: number,
      reference: string,
      signature: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'environment' is not null or undefined
      assertParamExists('getKineticTransaction', 'environment', environment)
      // verify required parameter 'index' is not null or undefined
      assertParamExists('getKineticTransaction', 'index', index)
      // verify required parameter 'reference' is not null or undefined
      assertParamExists('getKineticTransaction', 'reference', reference)
      // verify required parameter 'signature' is not null or undefined
      assertParamExists('getKineticTransaction', 'signature', signature)
      const localVarPath = `/api/transaction/kinetic-transaction/{environment}/{index}`
        .replace(`{${'environment'}}`, encodeURIComponent(String(environment)))
        .replace(`{${'index'}}`, encodeURIComponent(String(index)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (reference !== undefined) {
        localVarQueryParameter['reference'] = reference
      }

      if (signature !== undefined) {
        localVarQueryParameter['signature'] = signature
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestBlockhash: async (
      environment: string,
      index: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'environment' is not null or undefined
      assertParamExists('getLatestBlockhash', 'environment', environment)
      // verify required parameter 'index' is not null or undefined
      assertParamExists('getLatestBlockhash', 'index', index)
      const localVarPath = `/api/transaction/latest-blockhash/{environment}/{index}`
        .replace(`{${'environment'}}`, encodeURIComponent(String(environment)))
        .replace(`{${'index'}}`, encodeURIComponent(String(index)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {number} dataLength
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMinimumRentExemptionBalance: async (
      environment: string,
      index: number,
      dataLength: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'environment' is not null or undefined
      assertParamExists('getMinimumRentExemptionBalance', 'environment', environment)
      // verify required parameter 'index' is not null or undefined
      assertParamExists('getMinimumRentExemptionBalance', 'index', index)
      // verify required parameter 'dataLength' is not null or undefined
      assertParamExists('getMinimumRentExemptionBalance', 'dataLength', dataLength)
      const localVarPath = `/api/transaction/minimum-rent-exemption-balance/{environment}/{index}`
        .replace(`{${'environment'}}`, encodeURIComponent(String(environment)))
        .replace(`{${'index'}}`, encodeURIComponent(String(index)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (dataLength !== undefined) {
        localVarQueryParameter['dataLength'] = dataLength
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} signature
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction: async (
      environment: string,
      index: number,
      signature: string,
      commitment: Commitment,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'environment' is not null or undefined
      assertParamExists('getTransaction', 'environment', environment)
      // verify required parameter 'index' is not null or undefined
      assertParamExists('getTransaction', 'index', index)
      // verify required parameter 'signature' is not null or undefined
      assertParamExists('getTransaction', 'signature', signature)
      // verify required parameter 'commitment' is not null or undefined
      assertParamExists('getTransaction', 'commitment', commitment)
      const localVarPath = `/api/transaction/transaction/{environment}/{index}/{signature}`
        .replace(`{${'environment'}}`, encodeURIComponent(String(environment)))
        .replace(`{${'index'}}`, encodeURIComponent(String(index)))
        .replace(`{${'signature'}}`, encodeURIComponent(String(signature)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (commitment !== undefined) {
        localVarQueryParameter['commitment'] = commitment
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary
     * @param {MakeTransferRequest} makeTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeTransfer: async (
      makeTransferRequest: MakeTransferRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'makeTransferRequest' is not null or undefined
      assertParamExists('makeTransfer', 'makeTransferRequest', makeTransferRequest)
      const localVarPath = `/api/transaction/make-transfer`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(makeTransferRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} reference
     * @param {string} signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKineticTransaction(
      environment: string,
      index: number,
      reference: string,
      signature: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getKineticTransaction(
        environment,
        index,
        reference,
        signature,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestBlockhash(
      environment: string,
      index: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LatestBlockhashResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestBlockhash(environment, index, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {number} dataLength
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMinimumRentExemptionBalance(
      environment: string,
      index: number,
      dataLength: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MinimumRentExemptionBalanceResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMinimumRentExemptionBalance(
        environment,
        index,
        dataLength,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} signature
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransaction(
      environment: string,
      index: number,
      signature: string,
      commitment: Commitment,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(
        environment,
        index,
        signature,
        commitment,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary
     * @param {MakeTransferRequest} makeTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async makeTransfer(
      makeTransferRequest: MakeTransferRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.makeTransfer(makeTransferRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TransactionApiFp(configuration)
  return {
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} reference
     * @param {string} signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKineticTransaction(
      environment: string,
      index: number,
      reference: string,
      signature: string,
      options?: any,
    ): AxiosPromise<Array<Transaction>> {
      return localVarFp
        .getKineticTransaction(environment, index, reference, signature, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestBlockhash(environment: string, index: number, options?: any): AxiosPromise<LatestBlockhashResponse> {
      return localVarFp.getLatestBlockhash(environment, index, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {number} dataLength
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMinimumRentExemptionBalance(
      environment: string,
      index: number,
      dataLength: number,
      options?: any,
    ): AxiosPromise<MinimumRentExemptionBalanceResponse> {
      return localVarFp
        .getMinimumRentExemptionBalance(environment, index, dataLength, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {string} environment
     * @param {number} index
     * @param {string} signature
     * @param {Commitment} commitment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(
      environment: string,
      index: number,
      signature: string,
      commitment: Commitment,
      options?: any,
    ): AxiosPromise<GetTransactionResponse> {
      return localVarFp
        .getTransaction(environment, index, signature, commitment, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary
     * @param {MakeTransferRequest} makeTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeTransfer(makeTransferRequest: MakeTransferRequest, options?: any): AxiosPromise<Transaction> {
      return localVarFp.makeTransfer(makeTransferRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * TransactionApi - interface
 * @export
 * @interface TransactionApi
 */
export interface TransactionApiInterface {
  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} reference
   * @param {string} signature
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApiInterface
   */
  getKineticTransaction(
    environment: string,
    index: number,
    reference: string,
    signature: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<Transaction>>

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApiInterface
   */
  getLatestBlockhash(
    environment: string,
    index: number,
    options?: AxiosRequestConfig,
  ): AxiosPromise<LatestBlockhashResponse>

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {number} dataLength
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApiInterface
   */
  getMinimumRentExemptionBalance(
    environment: string,
    index: number,
    dataLength: number,
    options?: AxiosRequestConfig,
  ): AxiosPromise<MinimumRentExemptionBalanceResponse>

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} signature
   * @param {Commitment} commitment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApiInterface
   */
  getTransaction(
    environment: string,
    index: number,
    signature: string,
    commitment: Commitment,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetTransactionResponse>

  /**
   *
   * @summary
   * @param {MakeTransferRequest} makeTransferRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApiInterface
   */
  makeTransfer(makeTransferRequest: MakeTransferRequest, options?: AxiosRequestConfig): AxiosPromise<Transaction>
}

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI implements TransactionApiInterface {
  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} reference
   * @param {string} signature
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getKineticTransaction(
    environment: string,
    index: number,
    reference: string,
    signature: string,
    options?: AxiosRequestConfig,
  ) {
    return TransactionApiFp(this.configuration)
      .getKineticTransaction(environment, index, reference, signature, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getLatestBlockhash(environment: string, index: number, options?: AxiosRequestConfig) {
    return TransactionApiFp(this.configuration)
      .getLatestBlockhash(environment, index, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {number} dataLength
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getMinimumRentExemptionBalance(
    environment: string,
    index: number,
    dataLength: number,
    options?: AxiosRequestConfig,
  ) {
    return TransactionApiFp(this.configuration)
      .getMinimumRentExemptionBalance(environment, index, dataLength, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {string} environment
   * @param {number} index
   * @param {string} signature
   * @param {Commitment} commitment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public getTransaction(
    environment: string,
    index: number,
    signature: string,
    commitment: Commitment,
    options?: AxiosRequestConfig,
  ) {
    return TransactionApiFp(this.configuration)
      .getTransaction(environment, index, signature, commitment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary
   * @param {MakeTransferRequest} makeTransferRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionApi
   */
  public makeTransfer(makeTransferRequest: MakeTransferRequest, options?: AxiosRequestConfig) {
    return TransactionApiFp(this.configuration)
      .makeTransfer(makeTransferRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
